import { type NextRequest, NextResponse } from "next/server"

export async function POST(request: NextRequest) {
  try {
    const { applicationUrl, testCase } = await request.json()

    const seleniumCode = `#!/usr/bin/env python3
"""
Selenium Test: ${testCase.title}
Generated by JIRA Test AI
Target Application: ${applicationUrl || "https://v0-product-crud-app.vercel.app/"}
"""

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.ui import Select
from selenium.common.exceptions import TimeoutException, NoSuchElementException
import time
import sys

class AddInstrumentTest:
    def __init__(self):
        self.driver = None
        self.wait = None
        self.application_url = "${applicationUrl || "https://v0-product-crud-app.vercel.app/"}"
        
    def setup(self):
        """Initialize the WebDriver"""
        print("üöÄ Setting up Chrome WebDriver...")
        options = webdriver.ChromeOptions()
        options.add_argument("--start-maximized")
        options.add_argument("--disable-blink-features=AutomationControlled")
        
        try:
            self.driver = webdriver.Chrome(options=options)
            self.wait = WebDriverWait(self.driver, 10)
            print("‚úÖ WebDriver initialized successfully")
            return True
        except Exception as e:
            print(f"‚ùå Failed to initialize WebDriver: {e}")
            return False
    
    def navigate_to_application(self):
        """Navigate to the trading application"""
        print(f"üåê Navigating to {self.application_url}")
        try:
            self.driver.get(self.application_url)
            self.wait.until(EC.presence_of_element_located((By.TAG_NAME, "body")))
            print("‚úÖ Successfully loaded application")
            return True
        except TimeoutException:
            print("‚ùå Failed to load application - timeout")
            return False
    
    def click_add_instrument_button(self):
        """Click the Add Instrument button"""
        print("üîò Looking for 'Add Instrument' button...")
        try:
            # Try multiple possible selectors for the Add Instrument button
            selectors = [
                "//button[contains(text(), 'Add Instrument')]",
                "//button[contains(@class, 'add') and contains(text(), 'Instrument')]",
                "[data-testid='add-instrument-btn']",
                ".add-instrument-btn"
            ]
            
            button = None
            for selector in selectors:
                try:
                    if selector.startswith("//"):
                        button = self.wait.until(EC.element_to_be_clickable((By.XPATH, selector)))
                    else:
                        button = self.wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, selector)))
                    break
                except TimeoutException:
                    continue
            
            if button:
                button.click()
                print("‚úÖ Successfully clicked 'Add Instrument' button")
                time.sleep(1)  # Wait for modal/form to appear
                return True
            else:
                print("‚ùå Could not find 'Add Instrument' button")
                return False
                
        except Exception as e:
            print(f"‚ùå Error clicking Add Instrument button: {e}")
            return False
    
    def fill_instrument_form(self):
        """Fill out the instrument form with MSFT data"""
        print("üìù Filling out instrument form...")
        
        form_data = {
            "symbol": "MSFT",
            "name": "Microsoft Corporation", 
            "assetClass": "Stock",
            "price": "350.00"
        }
        
        try:
            # Fill Symbol field
            symbol_selectors = ["[name='symbol']", "[id='symbol']", "input[placeholder*='symbol' i]"]
            if self._fill_field(symbol_selectors, form_data["symbol"], "Symbol"):
                print("‚úÖ Symbol field filled")
            else:
                return False
            
            # Fill Name field  
            name_selectors = ["[name='name']", "[id='name']", "input[placeholder*='name' i]"]
            if self._fill_field(name_selectors, form_data["name"], "Name"):
                print("‚úÖ Name field filled")
            else:
                return False
            
            # Select Asset Class
            asset_selectors = ["[name='assetClass']", "[id='assetClass']", "select[placeholder*='asset' i]"]
            if self._select_dropdown(asset_selectors, form_data["assetClass"], "Asset Class"):
                print("‚úÖ Asset Class selected")
            else:
                return False
            
            # Fill Price field
            price_selectors = ["[name='price']", "[id='price']", "input[placeholder*='price' i]"]
            if self._fill_field(price_selectors, form_data["price"], "Price"):
                print("‚úÖ Price field filled")
            else:
                return False
                
            return True
            
        except Exception as e:
            print(f"‚ùå Error filling form: {e}")
            return False
    
    def _fill_field(self, selectors, value, field_name):
        """Helper method to fill a form field"""
        for selector in selectors:
            try:
                field = self.wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, selector)))
                field.clear()
                field.send_keys(value)
                return True
            except TimeoutException:
                continue
        print(f"‚ùå Could not find {field_name} field")
        return False
    
    def _select_dropdown(self, selectors, value, field_name):
        """Helper method to select from dropdown"""
        for selector in selectors:
            try:
                dropdown = self.wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, selector)))
                select = Select(dropdown)
                select.select_by_visible_text(value)
                return True
            except (TimeoutException, NoSuchElementException):
                continue
        print(f"‚ùå Could not find {field_name} dropdown")
        return False
    
    def submit_form(self):
        """Submit the instrument form"""
        print("üì§ Submitting form...")
        try:
            submit_selectors = [
                "//button[contains(text(), 'Submit')]",
                "//button[contains(text(), 'Add')]", 
                "//button[contains(text(), 'Save')]",
                "[type='submit']",
                ".submit-btn"
            ]
            
            button = None
            for selector in submit_selectors:
                try:
                    if selector.startswith("//"):
                        button = self.wait.until(EC.element_to_be_clickable((By.XPATH, selector)))
                    else:
                        button = self.wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, selector)))
                    break
                except TimeoutException:
                    continue
            
            if button:
                button.click()
                print("‚úÖ Form submitted successfully")
                time.sleep(2)  # Wait for submission to process
                return True
            else:
                print("‚ùå Could not find submit button")
                return False
                
        except Exception as e:
            print(f"‚ùå Error submitting form: {e}")
            return False
    
    def verify_instrument_added(self):
        """Verify that MSFT appears in the instruments table"""
        print("üîç Verifying MSFT appears in the table...")
        try:
            # Look for MSFT in the table
            msft_selectors = [
                "//td[contains(text(), 'MSFT')]",
                "//tr[contains(., 'MSFT')]",
                "[data-symbol='MSFT']"
            ]
            
            for selector in msft_selectors:
                try:
                    if selector.startswith("//"):
                        element = self.wait.until(EC.presence_of_element_located((By.XPATH, selector)))
                    else:
                        element = self.wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, selector)))
                    
                    if element:
                        print("‚úÖ MSFT successfully added to the table!")
                        return True
                except TimeoutException:
                    continue
            
            print("‚ùå MSFT not found in the table")
            return False
            
        except Exception as e:
            print(f"‚ùå Error verifying instrument: {e}")
            return False
    
    def cleanup(self):
        """Close the browser"""
        if self.driver:
            print("üßπ Cleaning up...")
            self.driver.quit()
            print("‚úÖ Browser closed")
    
    def run_test(self):
        """Execute the complete test"""
        print("=" * 60)
        print("üß™ STARTING SELENIUM TEST: Add New Trading Instrument")
        print("=" * 60)
        
        success = True
        
        # Setup
        if not self.setup():
            return False
        
        try:
            # Test steps
            steps = [
                ("Navigate to Application", self.navigate_to_application),
                ("Click Add Instrument Button", self.click_add_instrument_button),
                ("Fill Instrument Form", self.fill_instrument_form),
                ("Submit Form", self.submit_form),
                ("Verify Instrument Added", self.verify_instrument_added)
            ]
            
            for step_name, step_function in steps:
                print(f"\\nüìã Step: {step_name}")
                if not step_function():
                    success = False
                    break
                    
        except Exception as e:
            print(f"‚ùå Unexpected error during test: {e}")
            success = False
        
        finally:
            self.cleanup()
        
        print("\\n" + "=" * 60)
        if success:
            print("üéâ TEST PASSED: Add Instrument functionality works correctly!")
        else:
            print("üí• TEST FAILED: Issues found with Add Instrument functionality")
        print("=" * 60)
        
        return success

if __name__ == "__main__":
    test = AddInstrumentTest()
    success = test.run_test()
    sys.exit(0 if success else 1)
`

    return NextResponse.json({
      seleniumCode,
      message: "Selenium code generated successfully",
    })
  } catch (error) {
    console.error("Error generating Selenium code:", error)
    return NextResponse.json({ error: "Failed to generate Selenium code" }, { status: 500 })
  }
}
